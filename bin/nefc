#!/bin/bash

#: Valid Args
COMPILE="compile"
CLEAN="clean"
DEPENDENCIES="install"
COMPILE_CACHED_DEPENDENCIES="--use-cache"

DERIVED_DATA_DIR="nef/DerivedData"

#: terminal setup
bold=$(tput bold)
normal=$(tput sgr0)

red=$(tput setaf 1)
green=$(tput setaf 2)
required=$(tput setaf 222)
optional=$(tput setaf 230)
reset=$(tput sgr0)


#: IN ----------------- Check Args

##
#   printWrongArguments()
##
printWrongArguments() {
    echo ""
    echo "${bold}nefc ${normal}[${bold}$COMPILE ${normal}| ${bold}$DEPENDENCIES ${normal}| ${bold}$CLEAN${normal}]${bold} ${normal}<project> <options>"
    echo ""
    echo "    ${bold}$COMPILE${normal}  compile playground's pages for the selected project"
    echo "    ${bold}$DEPENDENCIES${normal}  builds dependencies in selected project"
    echo "    ${bold}$CLEAN${normal}  clean builds in selected project"
    echo ""
    echo "    ${optional}${bold}$COMPILE_CACHED_DEPENDENCIES${reset}${normal} is an option for '$COMPILE'. Use cached dependencies if it is possible. In another case, it will download and install them ${optional}[optional]${reset}"
    echo ""
}

##
#   printWrongConfig()
##
printWrongConfig() {
    echo ""
    echo "${bold}[!] ${normal}wrong configuration - should be ${bold}$COMPILE${normal} or ${bold}$DEPENDENCIES${normal} or ${bold}$CLEAN${normal}"
    echo ""
}

##
#   checkArguments(List<T> args) throws
#   - Parameter `args`: list of arguments received from command line
##
checkArguments() {
    # $0 - `nefc`
    # $1 - command
    # $2 - path
    # $3 - flag param

    local command="$1"
    local flag="$3"
    local isValidCommand=""

    if [ "$#" -lt 2 ] || [ "$#" -gt 3 ]; then printWrongArguments $0; exit 1; fi

    local validCommands=("$COMPILE" "$CLEAN" "$DEPENDENCIES")
    for valid in "${validCommands[@]}"; do
        if [ "$command" = "$valid" ]; then isValidCommand="$command"; fi
    done

    if [ "$isValidCommand" = "" ]; then
        printWrongConfig; exit 1
    elif [ "$command" = "$COMPILE" ]; then
        if [ "$flag" != "$COMPILE_CACHED_DEPENDENCIES" ] && [ "$flag" != "" ]; then
            printWrongArguments $0; exit 1;
        fi
    fi
}


#: ----------------- Dependencies

##
#   dependencies(String folder)
#   - Parameter `folder`: path to the project folder.
##
dependencies() {
    makeStructure "$1"
    buildDependencies "$1"
}

##
#   isPathFromDependencies(String path): Bool
#   - Parameter `path`: path to check if it is in dependencies folder
#   - Return `isDependency` 1 - is a dependency; 0 - another case
##
isPathFromDependencies() {
    local path="$1"  # parameter `path`

    podProject=$(eval echo "\"$path\" | grep '/Pods/' | awk '{ print length; }'")
    carthageProject=$(eval echo "\"$path\" | grep '/Carthage/' | awk '{ print length; }'")

    if [ "$podProject" != "" ] || [ "$carthageProject" != "" ]; then
      echo 1
    else
      echo 0
    fi
}

##
#   buildDependencies(String folder, String flag)
#   - Parameter `folder`: path to the project folder.
#   - parameter `flag`: configuration for building.
##
buildDependencies() {
    local path="$1" # parameter `folder`
    local flag="$2" # parameter `flag`

    buildPODS "$path" "$flag"
    buildCarthage "$path" "$flag"
    addPlaygroundReference "$path"
}

##
#   buildPODS(String folder, String flag) throws
#   - Parameter `folder`: path to the project folder.
#   - parameter `flag`: configuration for building.
##
buildPODS() {
    cd "$1"

    local flag="$2"
    local podfile="Podfile"
    local log="`pwd`/nef/log/pod-install.log"

    [ -f $podfile ] || return
    echo -ne "${normal}Installing ${green}Pods ${reset}..."

    find . -name $podfile -print0 | while IFS= read -r -d $'\0' podfilePath; do
        path="${podfilePath::${#podfilePath}-${#podfile}-1}"
        cd "$path"

        set +e
        if [ "$flag" = "$COMPILE_CACHED_DEPENDENCIES" ]; then
            pod install 1> "$log" 2>&1
        else
            pod install --repo-update 1> "$log" 2>&1
        fi

        installed=`grep "Pod installation complete" "$log"`
        set -e

        if [ "${#installed}" -gt 0 ]; then
            echo " ✅"
        else
            echo " ❌"
            echo "${bold}${red}error: ${reset}${bold}pod install${normal} review 'nef/log/pod-install.log' for more information."
            exit 1
        fi
    done
}

##
#   buildCarthage(String folder, String flag) throws
#   - Parameter `folder`: path to the project folder.
#   - parameter `flag`: configuration for building.
##
buildCarthage() {
    cd "$1"
    local project="$1"
    local flag="$2"
    local cartfile="Cartfile"
    local log="`pwd`/nef/log/carthage-install.log"

    [ -f $cartfile ] || return
    echo -ne "${normal}Installing ${green}Carthage ${reset}..."

    # build
    playgroundPagesForProjectPath "$project"
    playgroundPage=${playgroundPagesForProjectPath[0]}
    platformIOS=$(isPlatformIOSPlaygroundPage "$playgroundPage")
    [ $platformIOS -eq 1 ] && platform="iOS" || platform="osx"

    if [ "$flag" = "$COMPILE_CACHED_DEPENDENCIES" ]; then
        carthage update --cache-builds --platform $platform 1> "$log" 2>&1
    else
        carthage update --platform $platform 1> "$log" 2>&1
    fi

    # check errors
    installed=`grep "Build Failed" "$log"`
    errors=`grep "error:" "$log"`
    failed=`grep "failed with exit code" "$log"`

    if [ "${#installed}" -eq 0 ] && [ "${#errors}" -eq 0 ] && [ "${#failed}" -eq 0 ]; then
        createEmptyWorkspace "$project"
        echo " ✅"
    else
        echo " ❌"
        echo "${bold}${red}error: ${reset}${bold}carthage install${normal} review 'nef/log/carthage-install.log' for more information."
        exit 1
    fi
}

##
#   createEmptyWorkspace(String folder)
#   - Parameter `folder`: path to the project folder.
##
createEmptyWorkspace() {
    cd "$1"

    find . -name '*.pbxproj' -print0 | while IFS= read -r -d $'\0' project; do
        workspacePath=$(workspaceForProjectPath "$1" "$project")
        workspaceExtension=$(echo "$workspacePath" | rev | cut -d'.' -f1 | rev)
        workspaceName=$(echo "$workspacePath" | rev | cut -d'/' -f 1 | rev | cut -d'.' -f 1)
        workspace="$workspaceName.xcworkspace"
        isDependency=$(isPathFromDependencies "$workspacePath")

        ([ "$workspaceExtension" = "xcworkspace" ] || [ $isDependency -eq 1 ]) && continue

        content="<?xml version=\"1.0\" encoding=\"UTF-8\"?>
         <Workspace
            version = \"1.0\">
            <FileRef location = \"container:$workspaceName.xcodeproj\"></FileRef>
         </Workspace>"

        mkdir "$workspace"
        echo "$content" > "$workspace/contents.xcworkspacedata"
    done
}


#: ----------------- Compile

##
#   compile(String folder, String flag) throws
#   - Parameter `folder`: path to the project folder.
#   - parameter `flag`: configuration for building.
##
compile() {
    local flag="$2"

    makeStructure "$1" "$flag"
    buildDependencies "$1" "$flag"
    buildProject "$1" "$flag"
    copyFrameworks "$1"
    compilePlaygroundPages "$1"
}

##
#   buildProject(String folder, String flag) throws
#   - Parameter `folder`: path to the project folder.
#   - parameter `flag`: configuration for building.
##
buildProject() {
    cd "$1"          # parameter `folder`
    local flag="$2"  # parameter `flag`
    local logPath="nef/log"

    find . -name '*.pbxproj' -print0 | while IFS= read -r -d $'\0' project; do
        isDependency=$(isPathFromDependencies "$project")
        [ $isDependency -eq 1 ] && continue

        # build
        workspace=$(workspaceForProjectPath "$1" "$project")
        workspaceName=$(echo "$workspace" | cut -d'/' -f 2)
        schemeName=$(schemeNameFromProject "$project")
        sdk=$(sdkForWorkspaceAndScheme "$workspace" "$schemeName")
        log="$logPath/$workspaceName.log"

        echo -ne "${reset}Building ${green}$workspaceName${normal} ($schemeName) ..."

        needBuildProject=$(shouldBuildWorkspace "$workspace" "$flag")
        if [ "$needBuildProject" = "1" ]; then
            set +e
            xcodebuild -workspace "$workspace" -sdk "$sdk" -scheme "$schemeName" -derivedDataPath "$DERIVED_DATA_DIR" -configuration Debug 1> "$log" 2>&1
            installed=`grep "BUILD SUCCEEDED" "$log"`
            set -e
        else
            installed="OK!"
        fi

        if [ "${#installed}" -gt 0 ]; then
            echo " ✅"
        else
            echo " ❌"
            echo "${bold}${red}error: ${reset}${bold}building $workspaceName${normal}"
            cat "$log"
            exit 1
        fi
    done
}

##
#   schemeNameFromProject(String projectPath): String
#   - Parameter `projectPath`: path to the *.pbxproj file.
#   - Return `scheme name`
##
schemeNameFromProject() {
    local project="$1"  # parameter `project`

    targetNative="sed -n '/Begin PBXNativeTarget section/, /End PBXNativeTarget section/p'"
    targetAggregate="sed -n '/Begin PBXAggregateTarget section/, /End PBXAggregateTarget section/p'"
    targetName="grep 'name = ' | awk -F' = ' '{print \$2}' | awk -F';' '{print \$1}'"
    schemeName1=$(eval cat "\"$project\" | $targetNative | $targetName")
    schemeName2=$(eval cat "\"$project\" | $targetAggregate | $targetName")

    [ -z "$schemeName1" ] && echo "$schemeName2" || echo "$schemeName1"
}

##
#   workspaceForProjectPath(String folder, String projectPath): String
#   - Parameter `folder`: path to the project folder.
#   - Parameter `projectPath`: path to the *.pbxproj file.
#   - Return `workspace` path
##
workspaceForProjectPath() {
    local path="$1"         # parameter `folder`
    local projectPath="$2"  # parameter `projectPath`

    cd "$path"

    local xcprojectPath=$(echo "$projectPath" | rev | cut -d'/' -f 2- | rev)
    local xcprojectNoExtension=$(echo "$xcprojectPath" | rev | cut -d'.' -f 2- | rev)

    if [ -d "$xcprojectNoExtension.xcworkspace" ]; then
        echo "$xcprojectNoExtension.xcworkspace"
    else
        echo "$xcprojectNoExtension.xcodeproj"
    fi
}

##
#   sdkForWorkspaceAndScheme(String workspace, String schemeName): String
#   - Parameter `workspace`
#   - Parameter `schemeName`
#   - Return `sdk` to compile the target `schemeName` in `workspace`
##
sdkForWorkspaceAndScheme() {
  local workspace="$1"   # parameter `workspace`
  local schemeName="$2"  # parameter `schemeName`

  isIPHONE=$(eval xcodebuild -workspace "$workspace" -scheme "$schemeName" -quiet -showBuildSettings 2>&1 | grep 'SDKROOT' | grep 'iPhone' | awk '{ print length; }')
  sdk="iphoneos"
  if [ "$isIPHONE" = "" ]; then
    sdk="macosx"
  fi

  echo $sdk
}

##
#   isPlatformIOSPlaygroundPage(String playgroundPagePath): String
#   - Parameter `playgroundPagePath`
#   - Return `isPlatformIOS` 1 - is target-platform iOS; 0 - another case
##
isPlatformIOSPlaygroundPage() {
  local playgroundPagePath="$1"   # parameter `playground`
  local playgroundInfo="$playgroundPagePath/../../contents.xcplayground"

  isPlatformIOS=$(eval cat "\"$playgroundInfo\"" | grep "target-platform='ios'" | awk '{ print length; }')
  if [ "$isPlatformIOS" = "" ]; then
    echo 0
  else
    echo 1
  fi
}

##
#   shouldBuildWorkspace(String workspace, String flag)
#   - Parameter `workspace`
#   - parameter `flag`: configuration for building.
#   - Return `shouldBuildWorkspace` 1 - yes (is not cached); 0 - no (cached)
##
shouldBuildWorkspace() {
    local workspace="$1" # parameter `workspace`
    local flag="$2"      # parameter `flag`

    local workspaceName=$(echo "$workspace" | rev | cut -d'/' -f 1 | rev | cut -d'.' -f 1)
    local workspaceFwPath="nef/build/fw/$workspaceName.framework"

    [ -d "$DERIVED_DATA_DIR/build" ] && [ -d "$workspaceFwPath" ] && [ "$flag" = "$COMPILE_CACHED_DEPENDENCIES" ] && echo 0;
    echo 1
}

##
#   addPlaygroundReference(String folder)
#   - Parameter `folder`: path to the project folder.
##
addPlaygroundReference() {
    projectPath="$1"
    cd "$projectPath"
    playgroundsForProjectPath "$projectPath"

    local logPath="nef/log"
    local pattern="<FileRef"

    find . -name '*.pbxproj' -print0 | while IFS= read -r -d $'\0' project; do
        workspace=$(workspaceForProjectPath "$1" "$project")
        workspaceExtension=$(echo "$workspace" | rev | cut -d'.' -f1 | rev)
        workspaceName=$(echo "$workspace" | rev | cut -d'/' -f 1 | rev | cut -d'.' -f 1)
        workspaceContent="$workspace/contents.xcworkspacedata"

        ! [ "$workspaceExtension" = "xcworkspace" ] && continue
        grep -q ".playground\"" "$workspaceContent"; [ $? -eq 0 ] && continue

        for playground in "${playgroundsForProjectPath[@]}"; do
            playgroundScaped=$(echo "$playground" | sed 's/\//\\\//g')
            sed -i '' "1,/<FileRef/s/<FileRef/<FileRef location = \"group:$playgroundScaped\"> <\/FileRef><FileRef/" "$workspaceContent"
        done

        tmp="$logPath/$workspaceName.tmp.xcworkspace"
        awk '{ gsub("FileRef><FileRef", "FileRef>\n<FileRef") }1' "$workspaceContent" 1> "$tmp"
        mv "$tmp" "$workspaceContent"
    done
}

##
#   playgroundsForProjectPath(String projectPath): [String]
#   - Parameter `projectPath`: path to project folder.
#   - Return list of path `playground`
##
playgroundsForProjectPath() {
    cd "$1"

    playgroundsForProjectPath=()
    while read -r -d $'\0' playground; do
        playground=$(echo "$playground" | rev | cut -d'/' -f1 | rev )
        playgroundsForProjectPath+=("$playground")
    done < <(find . -name '*.playground' -print0)

    declare -p playgroundsForProjectPath 1>/dev/null 2>/dev/null
}

##
#   playgroundPagesForProjectPath(String projectPath): [String]
#   - Parameter `projectPath`: path to project folder.
#   - Return list of the whole path `playground pages` in project
##
playgroundPagesForProjectPath() {
    cd "$1"

    playgroundPagesForProjectPath=()
    while read -r -d $'\0' page; do
        isDependency=$(isPathFromDependencies "$page")
        [ $isDependency -eq 1 ] && continue
        playgroundPagesForProjectPath+=("$page")
    done < <(find . -name '*.xcplaygroundpage' -print0)

    declare -p playgroundPagesForProjectPath 1>/dev/null 2>/dev/null
}

##
#   makeHeaders(String folder, String playgroundName): String
#   - Parameter `folder`: path to the project folder.
#   - Parameter `playgroundName`: playground page name (kind of: *.xcplaygroundpage)
#   - Return `output`: path to file ready to build - added headers
##
makeHeaders() {
    local content=$1    # parameter `folder`
    local playground=$2 # parameter `playgroundName`
    local outputFolder="nef/build/$playground"
    local output="$outputFolder/main.swift"

    libs=(`xcrun swiftc -emit-imported-modules "$content" | sort -r | grep -vE PlaygroundSupport`)

    local remove=()
    local imports=""

    for lib in "${libs[@]}"; do
        [ $lib = "" ] && continue
        remove+=("| sed s/\"import $lib\"//g")
        imports="import $lib$'\n'$imports"
    done

    mkdir -p "$outputFolder"

    if [ "${#remove[@]}" -ne 0 ]; then
        eval "{ echo $imports; cat \"$content\" ${remove[@]}; } > \"$output\""
    else
        eval "cat \"$content\" > \"$output\""
    fi

    echo "$output"
}

##
#   compilePlaygroundPages(String folder)
#   - Parameter `folder`: path to the project folder.
##
compilePlaygroundPages() {
    local projectFolder="$1"  # parameter `folder`
    playgroundPagesForProjectPath "$projectFolder"

    echo "${bold}Found ${#playgroundPagesForProjectPath[@]} playgrounds${normal}"

    for page in "${playgroundPagesForProjectPath[@]}"; do
        pageName=$(echo "$page" | rev | cut -d'/' -f 1 | rev)
        echo -ne "${normal}   Compiling ${green}$pageName${reset} ..."

        # paths
        baseFile=$(echo "$page" | cut -c 2-)
        baseAbsolute=$(echo "$projectFolder$baseFile")
        content="$baseAbsolute/Contents.swift"
        playgroundName=$(echo "$baseAbsolute" | rev | cut -d'/' -f 1 | cut -d'.' -f 2 | rev)

        # headers
        output=$(makeHeaders "$content" "$playgroundName")

        # compile
        compilePlaygroundPage "$output" "$playgroundName" "$baseAbsolute"
        echo " ✅"
    done
}

##
#   compilePlaygroundPage(String file, String playgroundName, String playgroundPage) throws
#   - Parameter `file`: path to file to compile
#   - Parameter `playgroundName`: playground page name (kind of: *.xcplaygroundpage)
#   - Parameter `playgroundPage`: path to the original playground's page
##
compilePlaygroundPage() {
    set +e
    local file="$1" # parameter `file`
    local playgroundName=$(echo "$2" | sed 's/ /_/g') # parameter `playgroundName`
    local playgroundPage="$3" # parameter `playground`
    local log="nef/log/$playgroundName.log"
    local sources="$playgroundPage/../../Sources"
    local iOSFwPath=`xcode-select -p`"/Platforms/iPhoneOS.platform/Developer/Library/Frameworks"
    local macOSFwPath=`xcode-select -p`"/Platforms/MacOSX.platform/Developer/Library/Frameworks"

    platformIOS=$(isPlatformIOSPlaygroundPage "$playgroundPage")
    hasSourceFolderFiles=$(ls "$sources" 2> /dev/null)

    # A. macOS paltform
    if [ "$platformIOS" -eq "0" ]; then
        if [ "${#hasSourceFolderFiles}" -gt 0 ]; then
          xcrun -k swiftc -D NOT_IN_PLAYGROUND -F "nef/build/fw" -F "$macOSFwPath" -Xlinker -rpath -Xlinker "$macOSFwPath" -lswiftCore "$file" "$sources"/* -o "nef/build/output/$playgroundName" 1> "$log" 2>&1
        else
          xcrun -k swiftc -D NOT_IN_PLAYGROUND -F "nef/build/fw" -F "$macOSFwPath" -Xlinker -rpath -Xlinker "$macOSFwPath" -lswiftCore "$file" -o "nef/build/output/$playgroundName" 1> "$log" 2>&1
        fi

    # B. iOS platform
    else
        if [ "${#hasSourceFolderFiles}" -gt 0 ]; then
          xcrun -k -sdk "iphoneos" swiftc -D NOT_IN_PLAYGROUND -target "arm64-apple-ios12.0" -F "nef/build/fw" -F "$iOSFwPath" -Xlinker -rpath -Xlinker "$iOSFwPath" -lswiftXCTest "$file" "$sources"/* -o "nef/build/output/$playgroundName" 1> "$log" 2>&1
        else
          xcrun -k -sdk "iphoneos" swiftc -D NOT_IN_PLAYGROUND -target "arm64-apple-ios12.0" -F "nef/build/fw" -F "$iOSFwPath" -Xlinker -rpath -Xlinker "$iOSFwPath" -lswiftXCTest "$file" -o "nef/build/output/$playgroundName" 1> "$log" 2>&1
        fi
    fi

    errors=`cat "$log" | awk '{print tolower($0)}' | grep "error:"`
    [ "${#errors}" -eq 0 ] && return 0

    echo " ❌"
    echo "$errors" | while read -r error; do echo "${bold}${red}error: ${normal}${reset}$error"; done
    exit 1
}

##
#   copyFrameworks(String folder)
#   - Parameter `folder`: path to the project folder.
##
copyFrameworks() {
    local projectFolder=$1  # parameter `folder`

    cd "$projectFolder"

    if [ ! -d "$DERIVED_DATA_DIR/build" ]; then
      echo "Copy ${green}frameworks${reset} ❌"
      exit 1
    fi

    cp -a $(find "$DERIVED_DATA_DIR/build" -name '*.framework') nef/build/fw 2>/dev/null
    echo "Copy ${green}frameworks${reset} ✅"
}

##
#   makeStructure(String folder, String flag)
#   - Parameter `folder`: path to the project folder.
#   - parameter `flag`: configuration for building.
##
makeStructure() {
    set +e
    local projectFolder="$1" # parameter `folder`
    local flag="$2"          # parameter `flag`

    cd "$projectFolder"

    if [ "$flag" != "$COMPILE_CACHED_DEPENDENCIES" ]; then
        cleanStructure "$projectFolder"
    fi

    mkdir -p nef/build/fw
    mkdir -p nef/build/output
    mkdir -p nef/log
    mkdir -p "$DERIVED_DATA_DIR"
}

cleanStructure() {
    set +e
    cd "$1" # parameter `folder`

    rm -r nef/build 1>/dev/null 2>/dev/null
    rm -r nef/log 1>/dev/null 2>/dev/null
    rm -r "$DERIVED_DATA_DIR" 1>/dev/null 2>/dev/null
}


#: - Clean

##
#   clean(String folder)
#   - Parameter `folder`: path to the project folder.
##
clean() {
    set +e

    echo -ne "${normal}Clean ${green}nef${reset} ... ";
    $(cleanNEF "$1"); echo "✅"

    echo -ne "${normal}Clean ${green}dependencies${reset} ... ";
    $(cleanDependencies "$1"); echo "✅"
}

##
#   cleanNEF(String folder)
#   - Parameter `folder`: path to the project folder.
##
cleanNEF() {
    cd "$1"
    rm nef.log 1>/dev/null 2>/dev/null
    rm -rf nef 1>/dev/null 2>/dev/null
}

##
#   cleanDependencies(String folder)
#   - Parameter `folder`: path to the project folder.
##
cleanDependencies() {
    $(cleanPODS "$1");
    $(cleanCarthage "$1");
}

cleanPODS() {
    cd "$1"
    pod deintegrate 1>/dev/null 2>/dev/null
    rm -rf Pods 2>/dev/null
    rm -rf build 2>/dev/null
    rm podfile.lock 2>/dev/null
    rm -rf ./*.xcworkspace 1>/dev/null 2>/dev/null
}

cleanCarthage() {
    cd "$1"
    rm -rf Carthage 2>/dev/null
    rm Cartfile.resolved 2>/dev/null
    rm -rf ./*.xcworkspace 1>/dev/null 2>/dev/null
}

#: MAIN
set -e
checkArguments $@

root=`pwd`
if [ -d "$root/$2" ]; then
  projectPath="$root/$2"
else
  projectPath="$2"
fi

if [ $1 = "$COMPILE" ]; then
    flag="$3"
    compile "$projectPath" "$flag"
elif [ $1 = "$DEPENDENCIES" ]; then
    dependencies "$projectPath"
else
    clean "$projectPath"
fi
